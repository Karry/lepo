{
    "docs": [
        {
            "location": "/",
            "text": "Welcome!\n\n\nLepo is a \ncontract-first\n API framework that enables you to design your API using the \nOpenAPI specification\n (formerly known as Swagger) and implement it in Python 3 and \nDjango\n.\n\n\nWhat does it mean when we say \ncontract-first\n? Contrast this to \ncode-first\n:\n\n\n\n\nCode-first\n: First write the implementation of your API endpoints. Interactive API documentation is generated from docstrings and other meta-data embedded in the implementation. The \nDjango REST Framework\n is a popular example of a framework that promotes code-first style.\n\n\nContract-first\n (or \nAPI first\n): Write the \ncontract\n of your API first in machine-readable documentation describing the available endpoints and their input and output. API calls are mapped into view functions using meta-data embedded in this machine-readable documentation. Other examples of contract-first frameworks include \nconnexion\n (using \nFlask\n) and \nApigee 127\n (using Node.js and Express).\n\n\n\n\nFeatures\n\n\n\n\nAutomatic routing of requests to endpoints\n\n\nBody and query parameter validation\n\n\nOutput validation\n\n\nEmbedded Swagger UI\n\n\n\n\nLicense\n\n\nThe MIT License (MIT)\n\nCopyright (c) 2017 Aarni Koskela, Santtu Pajukanta\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "Home"
        },
        {
            "location": "/#welcome",
            "text": "Lepo is a  contract-first  API framework that enables you to design your API using the  OpenAPI specification  (formerly known as Swagger) and implement it in Python 3 and  Django .  What does it mean when we say  contract-first ? Contrast this to  code-first :   Code-first : First write the implementation of your API endpoints. Interactive API documentation is generated from docstrings and other meta-data embedded in the implementation. The  Django REST Framework  is a popular example of a framework that promotes code-first style.  Contract-first  (or  API first ): Write the  contract  of your API first in machine-readable documentation describing the available endpoints and their input and output. API calls are mapped into view functions using meta-data embedded in this machine-readable documentation. Other examples of contract-first frameworks include  connexion  (using  Flask ) and  Apigee 127  (using Node.js and Express).",
            "title": "Welcome!"
        },
        {
            "location": "/#features",
            "text": "Automatic routing of requests to endpoints  Body and query parameter validation  Output validation  Embedded Swagger UI",
            "title": "Features"
        },
        {
            "location": "/#license",
            "text": "The MIT License (MIT)\n\nCopyright (c) 2017 Aarni Koskela, Santtu Pajukanta\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "License"
        },
        {
            "location": "/features/",
            "text": "Features\n\n\nFeatures marked with a checkbox are supported.\n\n\nThose without a checkbox aren't guaranteed to be supported.\n\n\nThe absence or presence of a feature here does not directly mean it will or won't be implemented,\nso this document also serves as a TODO list of sorts.\n\n\nPlatform features\n\n\n\n\n DRY API error handling\n\n\n DRY authentication and authorization\n\n\n DRY pagination\n\n\n\n\nOpenAPI Features\n\n\nThis list was built by manually scanning down the OpenAPI specification, so omissions are entirely possible.\n\n\n\n\n Path \n$ref\ns\n\n\n Path-level \nconsumes\n/\nproduces\n definitions\n\n\n Operation-level \nconsumes\n/\nproduces\n definitions\n\n\n References outside a single OpenAPI file (\"Relative Files With Embedded Schema\")\n\n\n\n\nDefinitions\n\n\n\n\n \n$ref\ns in definitions\n\n\n Model polymorphism (schema \ndiscriminator\n field)\n\n\n Population of default values within models\n\n\n\n\nParameters\n\n\n\n\n Path-level \nparameter\n definitions\n\n\n Operation-level \nparameter\n definitions\n\n\n Parameters in paths\n\n\n Parameters in query string\n\n\n Parameters in HTTP headers\n\n\n Parameters in HTTP body\n\n\n Primitive parameters in HTTP body\n\n\n Parameters in HTTP form data\n\n\n Body-type parameter schema validation\n\n\n Parameter type/format validation\n\n\n Parameter \nallowEmptyValue\n\n\n Parameter CSV/SSV/TSV/Pipes collection formats\n\n\n Parameter multi collection format\n\n\n Parameter defaults\n\n\n Parameter extended validation (\nmaximum\n/...)\n\n\n Parameter array \nitems\n validation\n\n\n Parameter Definitions Objects\n\n\n Parameter \n$ref\ns\n\n\n Replacement of entire \nparameters\n objects with \n$ref\ns\n\n\n\n\nResponses\n\n\n\n\n Operation response validation\n\n\n Operation response \n$ref\ns\n\n\n Operation response schema validation\n\n\n \nfile\n as operation response schema type\n\n\n Responses Definitions Objects\n\n\n Headers validation\n\n\n\n\nSecurity\n\n\n\n\n Operation security declarations\n\n\n Security Definitions Objects",
            "title": "Features"
        },
        {
            "location": "/features/#features",
            "text": "Features marked with a checkbox are supported.  Those without a checkbox aren't guaranteed to be supported.  The absence or presence of a feature here does not directly mean it will or won't be implemented,\nso this document also serves as a TODO list of sorts.",
            "title": "Features"
        },
        {
            "location": "/features/#platform-features",
            "text": "DRY API error handling   DRY authentication and authorization   DRY pagination",
            "title": "Platform features"
        },
        {
            "location": "/features/#openapi-features",
            "text": "This list was built by manually scanning down the OpenAPI specification, so omissions are entirely possible.    Path  $ref s   Path-level  consumes / produces  definitions   Operation-level  consumes / produces  definitions   References outside a single OpenAPI file (\"Relative Files With Embedded Schema\")",
            "title": "OpenAPI Features"
        },
        {
            "location": "/features/#definitions",
            "text": "$ref s in definitions   Model polymorphism (schema  discriminator  field)   Population of default values within models",
            "title": "Definitions"
        },
        {
            "location": "/features/#parameters",
            "text": "Path-level  parameter  definitions   Operation-level  parameter  definitions   Parameters in paths   Parameters in query string   Parameters in HTTP headers   Parameters in HTTP body   Primitive parameters in HTTP body   Parameters in HTTP form data   Body-type parameter schema validation   Parameter type/format validation   Parameter  allowEmptyValue   Parameter CSV/SSV/TSV/Pipes collection formats   Parameter multi collection format   Parameter defaults   Parameter extended validation ( maximum /...)   Parameter array  items  validation   Parameter Definitions Objects   Parameter  $ref s   Replacement of entire  parameters  objects with  $ref s",
            "title": "Parameters"
        },
        {
            "location": "/features/#responses",
            "text": "Operation response validation   Operation response  $ref s   Operation response schema validation    file  as operation response schema type   Responses Definitions Objects   Headers validation",
            "title": "Responses"
        },
        {
            "location": "/features/#security",
            "text": "Operation security declarations   Security Definitions Objects",
            "title": "Security"
        },
        {
            "location": "/getting-started/",
            "text": "Getting started\n\n\nWriting your API contract\n\n\nWrite the contract of the first version of your API in the \nOpenAPI format\n. You'll end up with a YAML file popularly called \nswagger.yml\n.\n\n\nswagger\n:\n \n\"2.0\"\n\n\ninfo\n:\n\n  \nversion\n:\n \n0.0.1\n\n  \ntitle\n:\n \nLepo Petstore\n\n  \ndescription\n:\n \nA sample API that uses a petstore as an example to \u2026\n\n\nhost\n:\n \nlocalhost:8000\n\n\nbasePath\n:\n \n/api\n\n\nschemes\n:\n\n  \n-\n \nhttp\n\n\nconsumes\n:\n\n  \n-\n \napplication/json\n\n\nproduces\n:\n\n  \n-\n \napplication/json\n\n\npaths\n:\n\n  \n/pets\n:\n\n    \nget\n:\n\n      \ndescription\n:\n \n|\n\n        \nReturns all pets from the system that the user has access to\n\n      \noperationId\n:\n \nfindPets\n\n      \nresponses\n:\n\n        \n200\n:\n\n          \ndescription\n:\n \nGreat success.\n\n\n\n\n\n\nNote the \noperationId\n field. It's converted from camel case to snake case (\nfindPets\n becomes \nfind_pets\n) and used to route an API call to the correct handler (or \nview\n in Django lingo).\n\n\nInstalling Lepo\n\n\nInstall Lepo into your environment (likely a \nvirtualenv\n) using \npip\n\n(or if you manage requirements using a requirements.txt file or similar, add it there).\n\n\n$ pip install lepo\n\n\n\n\n\nSince we're using a YAML-formatted API declaration, we'll also need the [PyYAML] library.\nIf you happen to be using JSON-formatted OpenAPI documents, you don't need this.\n\n\n$ pip install PyYAML\n\n\n\n\n\nAdd \nlepo\n to your \nINSTALLED_APPS\n. If you want to use the Swagger UI, also add \nlepo_doc\n.\n\n\nINSTALLED_APPS\n \n=\n \n[\n\n    \n# \u2026\n\n    \n'lepo'\n,\n\n    \n'lepo_doc'\n,\n\n\n]\n\n\n\n\n\n\nWiring up Lepo\n\n\nMake a Django app, say \npetstore\n, add it to \nINSTALLED_APPS\n, and hook the \nswagger.yml\n up to your application in \nurls.py\n:\n\n\nfrom\n \npkg_resources\n \nimport\n \nresource_filename\n\n\n\nfrom\n \ndjango.conf.urls\n \nimport\n \ninclude\n,\n \nurl\n\n\nfrom\n \ndjango.contrib\n \nimport\n \nadmin\n\n\n\nfrom\n \nlepo.router\n \nimport\n \nRouter\n\n\nfrom\n \nlepo.validate\n \nimport\n \nvalidate_router\n\n\nfrom\n \nlepo_doc.urls\n \nimport\n \nget_docs_urls\n\n\n\nfrom\n \n.\n \nimport\n \nviews\n\n\n\n\nrouter\n \n=\n \nRouter\n.\nfrom_file\n(\nresource_filename\n(\n__name__\n,\n \n'swagger.yml'\n))\n\n\nrouter\n.\nadd_handlers\n(\nviews\n)\n\n\nvalidate_router\n(\nrouter\n)\n\n\n\nurlpatterns\n \n=\n \n[\n\n    \nurl\n(\nr\n'^admin/'\n,\n \nadmin\n.\nsite\n.\nurls\n),\n\n    \nurl\n(\nr\n'^api/'\n,\n \ninclude\n(\nrouter\n.\nget_urls\n(),\n \n'api'\n)),\n\n    \nurl\n(\nr\n'^api/'\n,\n \ninclude\n(\nget_docs_urls\n(\nrouter\n,\n \n'api-docs'\n),\n \n'api-docs'\n)),\n\n\n]\n\n\n\n\n\n\nObserve it is your responsibility to mount the API at the correct base path. Lepo does not read \nbasePath\n from your \nswagger.yml\n.\n\n\nFinally, implement the operations in \npetstore/views.py\n:\n\n\nfrom\n \ndjango.http\n \nimport\n \nJSONResponse\n\n\n\ndef\n \nfind_pets\n(\nrequest\n):\n\n    \nreturn\n \nJSONResponse\n({\n'pets'\n:\n \n[]})",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#writing-your-api-contract",
            "text": "Write the contract of the first version of your API in the  OpenAPI format . You'll end up with a YAML file popularly called  swagger.yml .  swagger :   \"2.0\"  info : \n   version :   0.0.1 \n   title :   Lepo Petstore \n   description :   A sample API that uses a petstore as an example to \u2026  host :   localhost:8000  basePath :   /api  schemes : \n   -   http  consumes : \n   -   application/json  produces : \n   -   application/json  paths : \n   /pets : \n     get : \n       description :   | \n         Returns all pets from the system that the user has access to \n       operationId :   findPets \n       responses : \n         200 : \n           description :   Great success.   Note the  operationId  field. It's converted from camel case to snake case ( findPets  becomes  find_pets ) and used to route an API call to the correct handler (or  view  in Django lingo).",
            "title": "Writing your API contract"
        },
        {
            "location": "/getting-started/#installing-lepo",
            "text": "Install Lepo into your environment (likely a  virtualenv ) using  pip \n(or if you manage requirements using a requirements.txt file or similar, add it there).  $ pip install lepo  Since we're using a YAML-formatted API declaration, we'll also need the [PyYAML] library.\nIf you happen to be using JSON-formatted OpenAPI documents, you don't need this.  $ pip install PyYAML  Add  lepo  to your  INSTALLED_APPS . If you want to use the Swagger UI, also add  lepo_doc .  INSTALLED_APPS   =   [ \n     # \u2026 \n     'lepo' , \n     'lepo_doc' ,  ]",
            "title": "Installing Lepo"
        },
        {
            "location": "/getting-started/#wiring-up-lepo",
            "text": "Make a Django app, say  petstore , add it to  INSTALLED_APPS , and hook the  swagger.yml  up to your application in  urls.py :  from   pkg_resources   import   resource_filename  from   django.conf.urls   import   include ,   url  from   django.contrib   import   admin  from   lepo.router   import   Router  from   lepo.validate   import   validate_router  from   lepo_doc.urls   import   get_docs_urls  from   .   import   views  router   =   Router . from_file ( resource_filename ( __name__ ,   'swagger.yml' ))  router . add_handlers ( views )  validate_router ( router )  urlpatterns   =   [ \n     url ( r '^admin/' ,   admin . site . urls ), \n     url ( r '^api/' ,   include ( router . get_urls (),   'api' )), \n     url ( r '^api/' ,   include ( get_docs_urls ( router ,   'api-docs' ),   'api-docs' )),  ]   Observe it is your responsibility to mount the API at the correct base path. Lepo does not read  basePath  from your  swagger.yml .  Finally, implement the operations in  petstore/views.py :  from   django.http   import   JSONResponse  def   find_pets ( request ): \n     return   JSONResponse ({ 'pets' :   []})",
            "title": "Wiring up Lepo"
        },
        {
            "location": "/class-based-handlers/",
            "text": "Class based handlers\n\n\nLepo provides a base class for class based views that validate their input and output against the schema.\nMore documentation on this is TBD.",
            "title": "Class based handlers"
        },
        {
            "location": "/class-based-handlers/#class-based-handlers",
            "text": "Lepo provides a base class for class based views that validate their input and output against the schema.\nMore documentation on this is TBD.",
            "title": "Class based handlers"
        },
        {
            "location": "/concepts/",
            "text": "Concepts\n\n\nRouter\n\n\nThe \nlepo.router.Router\n class is the root class of the API.\n\n\nIt encapsulates the OpenAPI definition document and generates\nthe URL patterns that are to be mounted in a Django URLconf.\n\n\nView Decoration\n\n\nYou can decorate the views that end up calling handlers when you instantiate the router.\n\n\nFor instance, you will need to decorate the views to be CSRF exempt\nif you're using Django's default \nCSRF middleware\n\nand need to send POST (or PATCH, etc.) requests to your API.\n\n\nTo do this, turn your\n\n\nrouter\n.\nget_urls\n()\n\n\n\n\n\n\ninto\n\n\nfrom\n \nlepo.decorators\n \nimport\n \ncsrf_exempt\n\n\n\nrouter\n.\nget_urls\n(\ndecorate\n=\n(\ncsrf_exempt\n,))\n\n\n\n\n\n\n(Do note that this \ndoes\n indeed remove Django's CSRF protection from the API views.)\n\n\nHandler\n\n\nHandlers are the functions that do the actual API work.\n\n\nThey are mapped to the OpenAPI definition by way of the \noperationId\n\nfield available in Operation objects.\n\n\nHandler functions are superficially similar to plain Django view functions\naside from a few significant differences:\n\n\n\n\nrequest\n is the \nonly\n positional argument passed to a handler;\n  the other arguments are mapped from the OpenAPI operation's parameters\n  and passed in as keyword arguments (converted to \nsnake_case\n).\n\n\n\n\nException Handling\n\n\nYou can raise a \nlepo.excs.ExceptionalResponse\n (which wraps a Django \nresponse\n)\nanywhere within a handler invocation. These exceptions will be caught by the internal\n\nPathView\n class and the wrapped response used as the handler's response.\n\n\nThis is a pragmatic way to refactor behavior common to multiple handlers, e.g.\n\n\ndef\n \n_get_some_object\n(\nrequest\n,\n \nid\n):\n\n    \nif\n \nnot\n \nrequest\n.\nuser\n.\nis_authenticated\n():\n\n        \nraise\n \nExceptionalResponse\n(\nJsonResponse\n({\n'error'\n:\n \n'not authenticated'\n},\n \nstatus\n=\n401\n))\n\n    \ntry\n:\n\n        \nreturn\n \nObject\n.\nobjects\n.\nget\n(\npk\n=\nid\n)\n\n    \nexcept\n \nObjectDoesNotExist\n:\n\n        \nraise\n \nExceptionalResponse\n(\nJsonResponse\n({\n'error'\n:\n \n'no such object'\n},\n \nstatus\n=\n404\n))\n\n\n\n\ndef\n \nget_object_detail\n(\nrequest\n,\n \nid\n):\n\n    \nobject\n \n=\n \n_get_some_object\n(\nrequest\n,\n \nid\n)\n\n    \nreturn\n \n{\n'id'\n:\n \nobject\n.\nid\n}\n\n\n\n\ndef\n \ndelete_object\n(\nrequest\n,\n \nid\n):\n\n    \nobject\n \n=\n \n_get_some_object\n(\nrequest\n,\n \nid\n)\n\n    \nobject\n.\ndelete\n()\n\n    \nreturn\n \n{\n'id'\n:\n \nobject\n.\nid\n,\n \n'deleted'\n:\n \nTrue\n}",
            "title": "Concepts"
        },
        {
            "location": "/concepts/#concepts",
            "text": "",
            "title": "Concepts"
        },
        {
            "location": "/concepts/#router",
            "text": "The  lepo.router.Router  class is the root class of the API.  It encapsulates the OpenAPI definition document and generates\nthe URL patterns that are to be mounted in a Django URLconf.",
            "title": "Router"
        },
        {
            "location": "/concepts/#view-decoration",
            "text": "You can decorate the views that end up calling handlers when you instantiate the router.  For instance, you will need to decorate the views to be CSRF exempt\nif you're using Django's default  CSRF middleware \nand need to send POST (or PATCH, etc.) requests to your API.  To do this, turn your  router . get_urls ()   into  from   lepo.decorators   import   csrf_exempt  router . get_urls ( decorate = ( csrf_exempt ,))   (Do note that this  does  indeed remove Django's CSRF protection from the API views.)",
            "title": "View Decoration"
        },
        {
            "location": "/concepts/#handler",
            "text": "Handlers are the functions that do the actual API work.  They are mapped to the OpenAPI definition by way of the  operationId \nfield available in Operation objects.  Handler functions are superficially similar to plain Django view functions\naside from a few significant differences:   request  is the  only  positional argument passed to a handler;\n  the other arguments are mapped from the OpenAPI operation's parameters\n  and passed in as keyword arguments (converted to  snake_case ).",
            "title": "Handler"
        },
        {
            "location": "/concepts/#exception-handling",
            "text": "You can raise a  lepo.excs.ExceptionalResponse  (which wraps a Django  response )\nanywhere within a handler invocation. These exceptions will be caught by the internal PathView  class and the wrapped response used as the handler's response.  This is a pragmatic way to refactor behavior common to multiple handlers, e.g.  def   _get_some_object ( request ,   id ): \n     if   not   request . user . is_authenticated (): \n         raise   ExceptionalResponse ( JsonResponse ({ 'error' :   'not authenticated' },   status = 401 )) \n     try : \n         return   Object . objects . get ( pk = id ) \n     except   ObjectDoesNotExist : \n         raise   ExceptionalResponse ( JsonResponse ({ 'error' :   'no such object' },   status = 404 ))  def   get_object_detail ( request ,   id ): \n     object   =   _get_some_object ( request ,   id ) \n     return   { 'id' :   object . id }  def   delete_object ( request ,   id ): \n     object   =   _get_some_object ( request ,   id ) \n     object . delete () \n     return   { 'id' :   object . id ,   'deleted' :   True }",
            "title": "Exception Handling"
        },
        {
            "location": "/codegen/",
            "text": "Code Generation\n\n\nYou can use the \nlepo.codegen\n module to generate a handler stub file\nfrom an OpenAPI YAML/JSON file.\n\n\nCommand line usage\n\n\npython -m lepo.codegen swagger.yaml > handlers.py",
            "title": "Codegen"
        },
        {
            "location": "/codegen/#code-generation",
            "text": "You can use the  lepo.codegen  module to generate a handler stub file\nfrom an OpenAPI YAML/JSON file.",
            "title": "Code Generation"
        },
        {
            "location": "/codegen/#command-line-usage",
            "text": "python -m lepo.codegen swagger.yaml > handlers.py",
            "title": "Command line usage"
        }
    ]
}